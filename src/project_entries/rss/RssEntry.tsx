import { Project } from "../../routes/projects/SingleProjectPage/project.ts"
import { RUST } from "../../routes/projects/SingleProjectPage/technology.tsx"
import {
  COPYABLE_COMMAND_LINK,
  CRATES_LINK,
  GITHUB_LINK,
} from "../../routes/projects/SingleProjectPage/links.tsx"
import ProjWrapper from "../../components/project_entry_utils/ProjWrapper.tsx"
import usage from "./assets/usage.png"
import normal_usage from "./assets/normal_usage.png"
import layout from "./assets/layout.png"
import editing from "./assets/editing.png"
import other_commands from "./assets/other_commands.txt"
import Pp from "../../components/project_entry_utils/Pp.tsx"
import Pa from "../../components/project_entry_utils/Pa.tsx"
import Pul from "../../components/project_entry_utils/Pul.tsx"
import Pli from "../../components/project_entry_utils/Pli.tsx"
import Pmono from "../../components/project_entry_utils/Pmono.tsx"
import Ph1 from "../../components/project_entry_utils/Ph1.tsx"
import Pol from "../../components/project_entry_utils/Pol.tsx"
import Pimg from "../../components/project_entry_utils/Pimg.tsx"
import PmarkdownSrc from "../../components/project_entry_utils/PmarkdownSrc.tsx"
//
export const RssProject: Project = {
  name: "rss",
  title: "RSS",
  subtitle:
    "Single file Rust projects with embedded binary enable Rust's use as a scripting language",
  image: { image: usage, alt: "Image of the RSS tool recompiling a file" },
  ms_since_epoch: 1716902340000,
  page: RssPage,
  technologies: [RUST],
  links: [
    { url: "https://github.com/Robert-M-Lucas/rss2", type: GITHUB_LINK },
    { url: "https://crates.io/crates/rs-script", type: CRATES_LINK },
    { url: "cargo install rs-script", type: COPYABLE_COMMAND_LINK },
  ],
}

function RssPage() {
  return (
    <ProjWrapper>
      <Pp>
        I created RSS (RS like <Pmono>.rs</Pmono> files and S for script) as I
        wanted to use Rust as a scripting language due to its strong typing,
        matching patterns, and performance that Python lacks. While a
        single-file scripting format{" "}
        <Pa
          href={
            "https://doc.rust-lang.org/cargo/reference/unstable.html#script"
          }
        >
          does exist
        </Pa>
        , it is notably lacking some key features:
      </Pp>
      <Pul>
        <Pli>It has almost non-existent IDE support (most important)</Pli>
        <Pli>
          Its compiled binaries stored in global directory (using space in a
          hidden way)
        </Pli>
        <Pli>Some Rust features/niceties require multiple files</Pli>
        <Pli>
          While Python doesn't have this either, storing a full project allows
          additional metadata files to be hidden in the single{" "}
          <Pmono>rss</Pmono> file
        </Pli>
      </Pul>
      <Ph1>File Structure</Ph1>
      <Pp>
        My solution is quite simple however its implementation has some hidden
        complexities. In general, a full Rust project is simply stored as a zip
        in a single file, with an appended binary. Here is a full breakdown:
      </Pp>
      <Pol>
        <Pli>
          A shebang to make the file executable with a{" "}
          <Pmono>./my_file.rss</Pmono> command on Linux. This must be at the
          start of the file to work.
        </Pli>
        <Pli>
          The length of the zipped project in bytes in a fixed-size integer
        </Pli>
        <Pli>The zipped project</Pli>
        <Pli>The length of the target triple</Pli>
        <Pli>
          The target triple indicating what target the attached binary is
          compiled for
        </Pli>
        <Pli>The length of the binary (0 if not present)</Pli>
        <Pli>The compiled binary</Pli>
        <Pli>
          The version of the file layout. This must be at the end as it must be
          in a known place between file layout versions and the shebang is at
          the start.
        </Pli>
      </Pol>
      <Pimg
        image={layout}
        alt={
          "Statistics about different parts of a .rss file, as generated by the RSS tool"
        }
        caption={
          <>
            File stats (with the <Pmono>-v</Pmono> verbose flag to show more
            information)
          </>
        }
      />
      <Pp>
        The layout indicator is particularly useful as it allows newer RSS
        version to identify older versions and suggest a solution. In general,
        however, the layout should remain stable and have very few changes.
      </Pp>
      <Ph1>Editing</Ph1>
      <Pp>
        Editing the file is really simple as it's just a matter of extracting
        the project to a temporary directory, starting an editor there, and, on
        close, compiling and creating the <Pmono>rss</Pmono> file by compressing
        the project structure and appending the binary. There is some extra
        consideration given for the normal use case as a new project will
        automatically include a temporary script in the project structure to{" "}
        <Pmono>cargo run</Pmono> the project in the original (non-temporary)
        directory for testing.
      </Pp>
      <Pp>
        There is also support for saving projects that don't compile, never
        saving the binary and regenerating it every <Pmono>rss run</Pmono>{" "}
        invocation, and, of course, the build (target) directory is always
        stripped before the project is compressed.
      </Pp>
      <Pimg
        image={editing}
        alt={"Command line output of the process of editing an RSS file"}
        caption={
          <>
            Command line output of editing a RSS file (with the{" "}
            <Pmono>-v</Pmono> verbose flag to show more information)
          </>
        }
      />
      <Ph1>Execution</Ph1>
      <Pp>
        The file is executed by copying the binary portion of the file to a
        temporary file, running it, and then deleting the temporary file. The
        aforementioned shebang allows a <Pmono>./my_file.rss</Pmono> execution
        syntax by specifying that the file should be executed using the RSS
        tool.
      </Pp>

      <Pp>
        Should the target triple not match the current platform, or the binary
        not be appended to the file at all, the file goes through all the steps
        of editing the file (without actually opening the editor) to obtain a
        compiled binary that can be used. This is, of course, slower than having
        a precompiled binary but is still surprisingly fast and allows the file
        size to be smaller (although the <Pmono>rss strip</Pmono> command does
        allow the binary to be removed for easier sharing).
      </Pp>

      <Ph1>Other Commands</Ph1>

      <Pp>
        You can find the other utility commands for this tool listed on the{" "}
        <Pa href={"https://crates.io/crates/rs-script"}>crates.io page</Pa>.
        Here is an excerpt:
      </Pp>

      <PmarkdownSrc
        markdownSrc={other_commands}
        caption={"crates.io excerpt"}
      />

      <Ph1>Conclusion</Ph1>
      <Pp>
        While initially I thought that using a full Rust project structure might
        be too clunky, this has quickly turned into a tool I use all the time
        due to its frictionless interface.
      </Pp>

      <Pimg
        image={normal_usage}
        alt={"Command line output of running an RSS word-counter script"}
        caption={
          "My typical usage, in this case a word counter being used in my notes folder"
        }
      />
    </ProjWrapper>
  )
}
